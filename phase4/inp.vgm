func vect<int> foo(vect<int> myVec){
	declr vect<int>v;
	declr vect<string>v1;
	
	expr v = v.append(4).append(5).sort();
	
	expr v = v.remove(0).remove(0);
	
	v.sort();
	v.append(5).sort();
	v.clear();
	return v;
}

func vect<int> vectConcat() {
	declr vect<int> vecA,vecB;
	declr int k, i;
	expr k = vecB.length();
	
	loop for(expr i = 0; (i lt k); incr(i)){
		vecA.append(vecB.at(i));
	}
	vecA.sort();
	return vecA;
}

struct myStructA{
	declr int itemA;
	declr string itemB;
};

struct myStructB{
	declr int itemC;
	declr myStructA itemD;
};


class someClass{
	
	
	declr matrix M[2][3];
	func int foo(myStructA Hey, string hey){
		
		declr graph G[10];
		expr G =
		{
			2:4,5;
			3:1;
			3:2,4;
		};
		expr M =
		[
			[1,3,4];[1,4,5];
		];
		expr Hey->itemB = hey;
		declr int k;
		return k;
	}
	func matrix boo(){
		declr int k;
		return M;
	}
};


class myClass{
	declr int cItemA;
	declr myStructB cItemB;
	declr someClass cItemC;
	
	func int foo(myStructA Hey, string hey){
		expr Hey->itemB = hey;
		declr int k;
		return k;
	}
	
	func int boo(myStructB yo){
		expr cItemB = yo;
		return yo->itemC;
		return 10;
	}
	
	func int myFunc(int abc, int k, string str, char c){
		declr int a, b;
		declr myStructB myObj;
		expr myObj = cItemB;
		expr cItemB->itemD->itemA = 10;
		declr int dslkf;
		expr abc = 10;
		expr str = "c";
		expr c = 'c';
		
		label3 :
		{
			expr c = 'l';
		}
		declr int i0, i1;
		expr a = 10;
		switch(add(a, b)){
			case 1:{
			
			}
			
			case 2:{
				switch(add(a, b)){
					case 1:{
				
					}
				
					case 2:{
					
					}
				
					case 3:{
					
					}
					
					default:{
				
					}
				}
			}
			
			case 3:{
			
			}
			
			default:{
			
			}
		}
		declr matrix A[2][2], B[2][2], C[2][2];
		return add_matx(A, B).trace();
		expr C = add_matx(A, B);
		return 1;
	}
	
};

func int main(myClass obj, float b, char c, string str, int myArr[]){
	declr int a;
	
	declr int arr[3];

	expr arr = [1,2,3];
!!	expr myArr = [1, 2, 3];!!
	
	declr matrix M1[2][3], M2[2][3];
	expr M1 = [[1, 2, 3]; [1.0, 2.0, 3.0];]; 
	
	expr M2 = [[4, 5, 6]; [1.0, 2.0, 3.0];];
	
	
	declr matrix M3[2][3];
	expr M3 = add_matx(M1, M2);
	expr M3 = add_matx(add_matx(M1, M2), M2);
	
	return 0;
	
}
