func vect<int> foo(vect<int> myVec) : FUNCTION HEAD{
	declr vect<int>v; : DECLARATION STATEMENT
	declr vect<string>v1; : DECLARATION STATEMENT
	declr int a, b, myInt; : DECLARATION STATEMENT
	declr bool myBool1, myBool2; : DECLARATION STATEMENT
	declr int ans; : DECLARATION STATEMENT
	
	
	expr ans = add(a, sub(b, mul(myInt, exp(10, 2)))); : EXPRESSION STATEMENT
	expr ans = not((myBool1 or (myBool2 and (a lt b)))); : EXPRESSION STATEMENT
	
	expr v = v.append(4).append(5).sort(); : EXPRESSION STATEMENT
	v.append(add(a, true)); : INDEPENDENT METHOD
	
	expr v = v.remove(0).remove(0); : EXPRESSION STATEMENT
	
	expr ans = v.length(); : EXPRESSION STATEMENT
	expr ans = v.append(4).append(5).sort().length(); : EXPRESSION STATEMENT
	
	v.sort(); : INDEPENDENT METHOD
	v.append(5).sort(); : INDEPENDENT METHOD
	v.clear(); : INDEPENDENT METHOD
	return v; : RETURN STATEMENT : RETURN STATEMENT
}

func vect<int> vectConcat() : FUNCTION HEAD {
	declr vect<int> vecA,vecB; : DECLARATION STATEMENT
	declr int k, i, j; : DECLARATION STATEMENT
	expr k = vecB.length(); : EXPRESSION STATEMENT
	
	loop for(expr i = 0; : EXPRESSION STATEMENT (i lt k); incr(i)){
		vecA.append(vecB.at(i)); : INDEPENDENT METHOD
		expr j = vecB.at(i); : EXPRESSION STATEMENT
	} : LOOP
	vecA.sort(); : INDEPENDENT METHOD
	return vecA; : RETURN STATEMENT : RETURN STATEMENT
}

struct myStructA{
	declr int itemA; : DECLARATION STATEMENT
	declr string itemB; : DECLARATION STATEMENT
}; : STRUCT DEFINITION

struct myStructB{
	declr matrix M[2][3]; : DECLARATION STATEMENT
	declr graph G[10]; : DECLARATION STATEMENT
	declr int itemC; : DECLARATION STATEMENT
	declr myStructA itemD; : DECLARATION STATEMENT
}; : STRUCT DEFINITION


class someClass{
	
	declr graph G1[10]; : DECLARATION STATEMENT
	declr matrix M[2][3]; : DECLARATION STATEMENT
	func int foo(myStructA Hey, string hey) : FUNCTION HEAD{
		
		declr graph G[10]; : DECLARATION STATEMENT
		expr G =
		{
			2:4,5;
			3:1;
			3:2,4;
		}; : EXPRESSION STATEMENT
		
		declr graph G2[4]; : DECLARATION STATEMENT
		expr G2 = {
			2: (1,3), (4,3.15);
			1: (2,9);
		}; : EXPRESSION STATEMENT
		
		declr vect<int> gvv; : DECLARATION STATEMENT
		expr gvv = G2.shortest_path(1,2); : EXPRESSION STATEMENT
		declr int gvv2; : DECLARATION STATEMENT
		expr gvv2 = G2.shortest_path_value(1,2); : EXPRESSION STATEMENT
		expr M =
		[
			[1,3,4];[1,4,5];
		]; : EXPRESSION STATEMENT
		expr Hey->itemB = hey; : EXPRESSION STATEMENT
		declr int k; : DECLARATION STATEMENT
		return k; : RETURN STATEMENT : RETURN STATEMENT
	}
	func matrix boo() : FUNCTION HEAD{
		declr int k; : DECLARATION STATEMENT
		return M; : RETURN STATEMENT : RETURN STATEMENT
	}
}; : CLASS DEFINITION


class myClass{
	declr int cItemA; : DECLARATION STATEMENT
	declr myStructB cItemB; : DECLARATION STATEMENT
	declr someClass cItemC; : DECLARATION STATEMENT
	
	func int foo(myStructA Hey, string hey) : FUNCTION HEAD{
		expr Hey->itemB = hey; : EXPRESSION STATEMENT
		declr int k; : DECLARATION STATEMENT
		return k; : RETURN STATEMENT : RETURN STATEMENT
	}
	
	func int boo(myStructB yo) : FUNCTION HEAD{
		expr cItemB = yo; : EXPRESSION STATEMENT
		return yo->itemC; : RETURN STATEMENT : RETURN STATEMENT
		return 10; : RETURN STATEMENT : RETURN STATEMENT
	}
	
	func int myFunc(int abc, int k, string str, char c, int myArr[]) : FUNCTION HEAD{
		declr int a, b; : DECLARATION STATEMENT
		declr myStructB myObj; : DECLARATION STATEMENT
		!!expr myArr = [1, 2, 3];!!
		expr myObj = cItemB; : EXPRESSION STATEMENT
		expr cItemB->itemD->itemA = 10; : EXPRESSION STATEMENT
		declr int dslkf; : DECLARATION STATEMENT
		expr abc = 10; : EXPRESSION STATEMENT
		expr str = "c"; : EXPRESSION STATEMENT
		expr c = 'c'; : EXPRESSION STATEMENT
		
		label3 :
		{
			expr c = 'l'; : EXPRESSION STATEMENT
		} : LABEL
		declr int i0, i1; : DECLARATION STATEMENT
		expr a = 10; : EXPRESSION STATEMENT
		switch(add(a, b)) : CONDITIONAL STATEMENT{
			case 1:{
			
			}
			
			case 2:{
				switch(add(a, b)) : CONDITIONAL STATEMENT{
					case 1:{
				
					}
				
					case 2:{
					
					}
				
					case 3:{
					
					}
					
					default:{
				
					}
				}
			}
			
			case 3:{
			
			}
			
			default:{
			
			}
		}
		declr matrix A[2][2], B[2][2], C[2][2]; : DECLARATION STATEMENT
		return add_matx(A, B).trace(); : RETURN STATEMENT : RETURN STATEMENT
		expr C = add_matx(A, B); : EXPRESSION STATEMENT
		return 1; : RETURN STATEMENT : RETURN STATEMENT
	}
	
}; : CLASS DEFINITION

func string getStr() : FUNCTION HEAD{
	return "Hello, World!\n"; : RETURN STATEMENT : RETURN STATEMENT
}

func int main() : FUNCTION HEAD{

	
	declr string str1, str2, str3; : DECLARATION STATEMENT
	declr int len; : DECLARATION STATEMENT!!
	expr str3 = call getStr();
	expr len = call getStr().strlen();
	expr len = str1.strlen();!!
	
	declr vect<int> myVec; : DECLARATION STATEMENT
	expr myVec = {1, 2, 3, 4, 5}; : EXPRESSION STATEMENT
	
	!!
	
	expr str1 = strjoin(str2.strcut(0, 5), strjoin(str3, call getStr()));!!
	
	expr str1 = "Hello"; : EXPRESSION STATEMENT
	expr str2 = strjoin("he", call getStr()); : EXPRESSION STATEMENT
	
	expr len = strcmp(str1, call getStr()); : EXPRESSION STATEMENT
	
	expr str2 = str1.strcut(add(1, 1), 3); : EXPRESSION STATEMENT
	declr int a; : DECLARATION STATEMENT
	
	declr int arr[3]; : DECLARATION STATEMENT

!!	expr arr = [1,2,3];!!
!!	expr myArr = [1, 2, 3];!!
	
	declr matrix M1[2][3], M2[2][3]; : DECLARATION STATEMENT
	expr M1 = [[1, 2, 3]; [1.0, 2.0, 3.0];]; : EXPRESSION STATEMENT 
	
	expr M2 = [[4, 5, 6]; [1.0, 2.0, 3.0];]; : EXPRESSION STATEMENT
	
	
	declr matrix M3[2][3]; : DECLARATION STATEMENT
	expr M3 = add_matx(M1, M2); : EXPRESSION STATEMENT
	expr M3 = add_matx(add_matx(M1, M2), mult_matx(M1, M2)).transpose(); : EXPRESSION STATEMENT
	expr a = add_matx(add_matx(M1, M2), mult_matx(M1, M2)).trace(); : EXPRESSION STATEMENT
	return 0; : RETURN STATEMENT : RETURN STATEMENT
	
}
