#include <bits/stdc++.h>
#include "improvisations.h"
using namespace std;

vector<int> foo ( vector<int> myVec )
	{
		vector<int> v;
		vector<string> v1;
		int a, b, myInt;
		bool myBool1, myBool2;
		int ans;
		cout << ans << a << endl;
		cout << "Hello, world\n" << endl;
		ans = (a+(b-(myInt*pow(10,2))));
		ans = !((myBool1||(myBool2&&(a<b))));
		{vector<int> temp = v;temp.push_back(4);v = temp;}
		{vector<int> temp = v;temp.push_back(5);v = temp;}
		{vector<int> temp = v;sort(temp.begin(), temp.end());v = temp;}
		v = v;
		{vector<int> temp = v;temp.push_back((a+true));v = temp;}

		{vector<int> temp = v;temp.erase(temp.begin()+0);v = temp;}
		{vector<int> temp = v;temp.erase(temp.begin()+0);v = temp;}
		v = v;
		ans = v.size();
		{vector<int> temp = v;temp.push_back(4);v = temp;}
		{vector<int> temp = v;temp.push_back(5);v = temp;}
		{vector<int> temp = v;sort(temp.begin(), temp.end());v = temp;}
		ans = v.size();
		{vector<int> temp = v;sort(temp.begin(), temp.end());v = temp;}

		{vector<int> temp = v;temp.push_back(5);v = temp;}
		{vector<int> temp = v;sort(temp.begin(), temp.end());v = temp;}

		{vector<int> temp = v;temp.clear();v = temp;}

		return v;
	}
vector<int> vectConcat ()
	{
		vector<int> vecA, vecB;
		int k, i, j;
		k = vecB.size();
		for(		i = 0;(i<k); i++ ) 		{
			{vector<int> temp = vecA;temp.push_back(vecB[i]);vecA = temp;}

			j = vecB[i];
		}

		{vector<int> temp = vecA;sort(temp.begin(), temp.end());vecA = temp;}

		return vecA;
	}
struct myStructA {
	int itemA;
	string itemB;
};
struct myStructB {
	graph G(10);
	int itemC;
	struct myStructA itemD;
};
class someClass {
		graph G1{10};
	matrix M{2, 3};
	int foo ( struct myStructA Hey, string hey )
		{
			graph G(10);
			G.addEdge(2, 4);
			G.addEdge(2, 5);
			G.addEdge(3, 1);
			G.addEdge(3, 2);
			G.addEdge(3, 4);
			G.setFlag(0);

			graph G2(4);
			G2.addWeightedEdge(2, 1, 3);
			G2.addWeightedEdge(2, 4, 3.15);
			G2.addWeightedEdge(1, 2, 9);
			G2.setFlag(1);

			vector<int> gvv;
			gvv = G2.bfs(4);

			M.vals = {{1,3,4},{1,4,5}};
			Hey.itemB = hey;
			int k;
			return k;
		}

	matrix boo ()
		{
			int k;
			return M;
		}

};
class myClass {
	int cItemA;
	struct myStructB cItemB;
	class someClass cItemC;
	int foo ( struct myStructA Hey, string hey )
		{
			Hey.itemB = hey;
			int k;
			return k;
		}

	int boo ( struct myStructB yo )
		{
			cItemB = yo;
			return yo.itemC;
			return 10;
		}

	int myFunc ( int abc, int k, string str, char c )
		{
			int a, b;
			struct myStructB myObj;
			myObj = cItemB;
			cItemB.itemD.itemA = 10;
			int dslkf;
			abc = 10;
			str = "c";
			c = 'c';
			label3: 			{
				c = 'l';
			}

			int i0, i1;
			a = 10;
			switch ((a+b)){
				case 1:
				{ }
				case 2:
				{
					switch ((a+b)){
						case 1:
						{ }
						case 2:
						{ }
						case 3:
						{ }
						default:
						{ }
					}

				}
				case 3:
				{ }
				default:
				{ }
			}

			matrix A(2, 2), B(2, 2), C(2, 2);
			{matrix _temp = add_matx(A, B);_flag = _temp.trace();}
			return _flag;

			return 1;
		}

};
string getStr ()
	{
		return "Hello, World!\n";
	}
int main ( class myClass obj, float b, char c, string str, int myArr[] )
	{
		string str1, str2, str3;
		int len;
		str3 = getStr();
		len = strlen(getStr());
		len = strlen(str1);
		vector<int> myVec;
		myVec = {1, 2, 3, 4, 5};
		len = strcmp(str1, getStr());
		str1 = (str2.substr(0, 5)+(str3+getStr()));
		int a;
		int arr[3];
		arr = {1,2,3};
		matrix M1(2, 3), M2(2, 3);
		M1.vals = {{1,2,3},{1.0,2.0,3.0}};
		M2.vals = {{4,5,6},{1.0,2.0,3.0}};
		matrix M3(2, 3);

		{matrix _temp = add_matx(add_matx(M1, M2), mult_matx(M1, M2)); _temp = _temp.transpose(); add_matx(add_matx(M1, M2), mult_matx(M1, M2)) = _temp;}

		{matrix _temp = add_matx(add_matx(M1, M2), mult_matx(M1, M2));_flag = _temp.trace();}
		a = _flag;
		return 0;
	}
