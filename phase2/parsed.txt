class myClass {
	declr int itemA; : DECLARATION STATEMENT
	declr float itemB, itemC; : DECLARATION STATEMENT
	declr struct myStruct itemD; : DECLARATION STATEMENT
	
	func void setItems(int a, float b, float c, myStruct d) : FUNCTION HEAD {
		expr itemA = a; : EXPRESSION STATEMENT
		expr itemB = b; : EXPRESSION STATEMENT
		expr itemC = c; : EXPRESSION STATEMENT
		expr itemD = d; : EXPRESSION STATEMENT
		return null; : RETURN STATEMENT
	}
	
	func int boo(int num) : FUNCTION HEAD {
		return mul(num, (num gt 10)); : RETURN STATEMENT
	}
	
	func myStruct foo(int p, int q) : FUNCTION HEAD {
		expr a = add(sItem1, mul(p, (q and call boo(q)))); : EXPRESSION STATEMENT
		sItem2.append(10); : INDEPENDENT METHOD
		expr itemD->sItem1 = sub(a, sItem2.append(call boo((a lt itemD->sItem3.strlen()))).sort().length()); : EXPRESSION STATEMENT
		return itemD; : RETURN STATEMENT
	}
}; : CLASS DEFINITION

struct myStruct {
	declr int sItem1; : DECLARATION STATEMENT
	declr vect<int> sItem2; : DECLARATION STATEMENT
	declr string sItem3; : DECLARATION STATEMENT
}; : STRUCT DEFINITION

func int main () : FUNCTION HEAD {
	return 1; : RETURN STATEMENT
}

func int main() : FUNCTION HEAD
{
	{}
	expr sdf = -78.5; : EXPRESSION STATEMENT
	expr sdf = -85; : EXPRESSION STATEMENT	
	{
		expr x = sdf; : EXPRESSION STATEMENT
		{expr sdf = sdf; : EXPRESSION STATEMENT}
	}

	declr matrix mat[2][3]; : DECLARATION STATEMENT
	expr mat = [[1,2,3];
	 			[2.0,3.5,4.8];
				]; : EXPRESSION STATEMENT
				
	expr myvec = {mat, 
				[[1,2,3];
	 			 [2.0,3.5,4.8];],
	 			{a, b, c}, 
	 			{},
	 			{
					1 : 2,3;
					2 : 1,4;
					3 : 1;
					4 : 2;
				}
				}; : EXPRESSION STATEMENT
				
				
	expr t = clear.append(4).sort(); : EXPRESSION STATEMENT
	expr s = clear.append(add(call foo(), (a and b))); : EXPRESSION STATEMENT
	expr s = clear.append(mat.trace()).remove(1); : EXPRESSION STATEMENT
	return myvec.append(clear.length()).remove(8); : RETURN STATEMENT
	expr s = myvec.append(8).append(9); : EXPRESSION STATEMENT
	
	
	return myvec.remove(clear.length()); : RETURN STATEMENT
	return myvec.remove(add(call foo(), (a and mat.trace()))); : RETURN STATEMENT
	
	
	return clear.remove(str.strcut(call a->foo(), (a or b))); : RETURN STATEMENT
	
	
	clear.append(4).sort(); : INDEPENDENT METHOD
	clear.append(add(call foo(), (a and b))); : INDEPENDENT METHOD
	clear.append(mat.trace()).remove(1); : INDEPENDENT METHOD
	myvec.append(clear.length()).remove(8); : INDEPENDENT METHOD
	myvec.append(8).append(9); : INDEPENDENT METHOD
	
	
	myvec.remove(clear.length()); : INDEPENDENT METHOD
	myvec.remove(add(call foo(), (a and mat.trace()))); : INDEPENDENT METHOD
	
	
	clear.remove(str.strcut(call a->foo(), (a or b))); : INDEPENDENT METHOD
	
	
	expr a = myvec.length(); : EXPRESSION STATEMENT
	myvec.sort(); : INDEPENDENT METHOD
	myvec.clear(); : INDEPENDENT METHOD
	expr a = myvec.at(3); : EXPRESSION STATEMENT
	expr C = add_matx(sub_matx(P, mult_matx(Q, R)), S); : EXPRESSION STATEMENT
	expr B = add_matx(A, B).transpose().trace(); : EXPRESSION STATEMENT
	expr B = A.trace(); : EXPRESSION STATEMENT
	expr myvec = G.dfs(3); : EXPRESSION STATEMENT
	
	expr str3 = strjoin(str1, str2); : EXPRESSION STATEMENT
	expr str4 = strjoin(strjoin(str1, str2), str2).strlen(); : EXPRESSION STATEMENT
	expr t8 = strcmp(strjoin(strjoin(call foo(), call boo()), call zoo()), str1.strcut(a, call foo())); : EXPRESSION STATEMENT
	expr str4 = strjoin(strjoin(call foo(), call boo()), call zoo()); : EXPRESSION STATEMENT
}


func int main() : FUNCTION HEAD
{
	
	loop for (expr i=0 ; : EXPRESSION STATEMENT (i lt 10); expr j = incr(i))
	{	
  		expr m = 0; : EXPRESSION STATEMENT
  		return {}; : RETURN STATEMENT
	} : LOOP
	loop for (expr i=0 ; : EXPRESSION STATEMENT (i lt 10); expr i = mul(i,3))
	{	
  		expr m = 0; : EXPRESSION STATEMENT
  		return {1, 2, 3}; : RETURN STATEMENT
	} : LOOP
	return {1 : 2,3;2 : 1,4;3 : 1;4 : 2;}; : RETURN STATEMENT
}

struct node
{
	declr string name; : DECLARATION STATEMENT
	declr char grade; : DECLARATION STATEMENT
	declr int marks; : DECLARATION STATEMENT
	declr float cgpa; : DECLARATION STATEMENT
	declr bool feeStatus; : DECLARATION STATEMENT
}; : STRUCT DEFINITION


class vehical {
    declr string type; : DECLARATION STATEMENT
    declr int regNo; : DECLARATION STATEMENT
    declr bool pollutionCheck; : DECLARATION STATEMENT
    func int getRegNo() : FUNCTION HEAD
    {
        declr int regNo; : DECLARATION STATEMENT
    }
    func void updatePollStatus ( bool val ) : FUNCTION HEAD
    {
        expr pollutionCheck = val; : EXPRESSION STATEMENT
        declr int nuldl; : DECLARATION STATEMENT
    }
}; : CLASS DEFINITION

func bool foo(int a, char b, vect<int> sdf, node sdffd) : FUNCTION HEAD
{
	declr graph G[4]; : DECLARATION STATEMENT
	expr G =
	{
		1 : 2,3;
		2 : 1,4;
		3 : 1;
		4 : 2;
	}; : EXPRESSION STATEMENT

	declr graph G[3]; : DECLARATION STATEMENT
	expr G =
	{
		1 : (2,8),(3,12);
		2 : (3,5);
	}; : EXPRESSION STATEMENT

	declr vect<int> myvec; : DECLARATION STATEMENT
	expr myvec = {1,2,3}; : EXPRESSION STATEMENT
	expr myvec = {1,bat,3}; : EXPRESSION STATEMENT
	expr myvec = {1,{1, str, {}},3}; : EXPRESSION STATEMENT

	if(A.strlen()) : CONDITIONAL STATEMENT
	{
		call sdf(); : CALL STATEMENT
		call sdfsd->sdf(); : CALL STATEMENT
		declr int a; : DECLARATION STATEMENT
		declr float f1, f2; : DECLARATION STATEMENT
	}
	else
	{
		declr vect < int > myVec; : DECLARATION STATEMENT 
		declr graph G[10]; : DECLARATION STATEMENT
	}

	declr vect<vect<int>> myvec; : DECLARATION STATEMENT

	switch(5) : CONDITIONAL STATEMENT
	{
		case 1:
		{
			declr int arr[10]; : DECLARATION STATEMENT
			declr int arr[10], barr[5]; : DECLARATION STATEMENT
		}	
		case 2:
		{
			expr adf = add(df, mul(a, div(sub(c, d), f))); : EXPRESSION STATEMENT
			declr string str1, str2; : DECLARATION STATEMENT
		}	
		default :
		{
			declr vect<int> myVec1, myVec2; : DECLARATION STATEMENT	
		}	
	}
}
