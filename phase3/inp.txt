
struct myStructA{
	declr int itemA;
	declr string itemB;
};

struct myStructB{
	declr int itemC;
	declr myStructA itemD;
};


class someClass{
	declr int a;
	declr int b;
	
	declr matrix M[2][3];
	func int foo(myStructA Hey, string hey){
		declr graph G[10];
		expr G =
		{
			2:4,5;
			3:1;
			3:2,4;
		};
		expr M =
		[
			[1,3,4];[1,4,5];
		];
		expr Hey->itemB = hey;
		declr int k;
	}
	func int boo(){
		declr int k;
	}
};


class myClass{
	declr int cItemA;
	declr myStructB cItemB;
	declr someClass cItemC;
	
	func int foo(myStructA Hey, string hey){
		expr Hey->itemB = hey;
		declr int k;
	}
	
	func int boo(myStructB yo){
		expr cItemB = yo;
		return yo->itemC;
	}
	
	func int myFunc(int abc, int k, string str, char c){
		declr myStructB myObj;
		!! expr myObj = cItemB; !!
		expr cItemB->itemD->itemA = 10;
		!! expr cItemB->itemD->itemA = 10; !!
		declr int a;
		expr abc = 10;
		expr str = "c";
		expr c = 'c';
		
		label3 :
		{
			expr c = 'l';
		}
		declr int a, b;
		expr a = 10;
		switch(add(a, b)){
			case 1:{
			
			}
			
			case 2:{
				switch(add(a, b)){
					case 1:{
				
					}
				
					case 2:{
					
					}
				
					case 3:{
					
					}
					
					default:{
				
					}
				}
			}
			
			case 3:{
			
			}
			
			default:{
			
			}
		}
		
	}
};

func int main(int a, myClass obj, float b, char c, string str){
	
	expr a = 10;
	expr str = "Hello, world";
	expr a = obj->cItemB->itemD->itemA;
	declr myStructA hey;
	expr a = call obj->foo(hey, "Hey");
	declr myStructB Yo;
	call obj->boo(Yo);
	
	call obj->cItemC->foo(hey, "Hey");
	expr a = call obj->cItemC->boo();
	label1 :
	{
		declr int a;
	}
	expr a = add(a, call obj->myFunc(5, (true or false), str, c));
	loop while(true){
		declr int i;
		if( ((a and b) or add(a, call obj->myFunc(5, 10, "Hema", 'c'))) ){
			
			call obj->myFunc(5, add(a, 10.0), "Hema", 'c');
			
		}
		declr int i;
		call obj->myFunc(i, 10, "Hema", 'c');
	}
	
}


	
func int main()
{
	declr int a;
	expr a = 10;
	return 10;
}


func vect<myStruct> matr_add (matrix A, matrix B){
    return add_matx(A, B);
}

func vect<M> boo(int num, float nums) {
	return mul(num, (num gt 10));
}
	
func vect<int> foo(int p, int q) {
	expr a = add(sItem1, mul(p, (q and call boo(q))));
	declr vect<int> a;
	sItem2.append(10);
	expr itemD->sItem1 = sub(a, sItem2.append(call boo((a lt itemD->sItem3.strlen()))).sort().length());
	return itemD;
}


