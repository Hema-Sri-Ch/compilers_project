
struct myStructA{
	declr int itemA; : DECLARATION STATEMENT
	declr string itemB; : DECLARATION STATEMENT
}; : STRUCT DEFINITION

struct myStructB{
	declr int itemC; : DECLARATION STATEMENT
	declr myStructA itemD; : DECLARATION STATEMENT
}; : STRUCT DEFINITION


class someClass{
	declr int a; : DECLARATION STATEMENT
	declr int b; : DECLARATION STATEMENT
	
	declr matrix M[2][3]; : DECLARATION STATEMENT
	func int foo(myStructA Hey, string hey) : FUNCTION HEAD{
		declr graph G[10]; : DECLARATION STATEMENT
		expr G =
		{
			2:4,5;
			3:1;
			3:2,4;
		}; : EXPRESSION STATEMENT
		expr M =
		[
			[1,3,4];[1,4,5];
		]; : EXPRESSION STATEMENT
		expr Hey->itemB = hey; : EXPRESSION STATEMENT
		declr int k; : DECLARATION STATEMENT
	}
	func int boo() : FUNCTION HEAD{
		declr int k; : DECLARATION STATEMENT
	}
}; : CLASS DEFINITION


class myClass{
	declr int cItemA; : DECLARATION STATEMENT
	declr myStructB cItemB; : DECLARATION STATEMENT
	declr someClass cItemC; : DECLARATION STATEMENT
	
	func int foo(myStructA Hey, string hey) : FUNCTION HEAD{
		expr Hey->itemB = hey; : EXPRESSION STATEMENT
		declr int k; : DECLARATION STATEMENT
	}
	
	func int boo(myStructB yo) : FUNCTION HEAD{
		expr cItemB = yo; : EXPRESSION STATEMENT
		return yo->itemC; : RETURN STATEMENT
	}
	
	func int myFunc(int abc, int k, string str, char c) : FUNCTION HEAD{
		declr myStructB myObj; : DECLARATION STATEMENT
		!! expr myObj = cItemB; !!
		expr cItemB->itemD->itemA = 10; : EXPRESSION STATEMENT
		!! expr cItemB->itemD->itemA = 10; !!
		declr int a; : DECLARATION STATEMENT
		expr abc = 10; : EXPRESSION STATEMENT
		expr str = "c"; : EXPRESSION STATEMENT
		expr c = 'c'; : EXPRESSION STATEMENT
		
		label3 :
		{
			expr c = 'l'; : EXPRESSION STATEMENT
		} : LABEL
		declr int a, b; : DECLARATION STATEMENT
		expr a = 10; : EXPRESSION STATEMENT
		switch(add(a, b)) : CONDITIONAL STATEMENT{
			case 1:{
			
			}
			
			case 2:{
				switch(add(a, b)) : CONDITIONAL STATEMENT{
					case 1:{
				
					}
				
					case 2:{
					
					}
				
					case 3:{
					
					}
					
					default:{
				
					}
				}
			}
			
			case 3:{
			
			}
			
			default:{
			
			}
		}
		
	}
}; : CLASS DEFINITION

func int main(int a, myClass obj, float b, char c, string str) : FUNCTION HEAD{
	
	expr a = 10; : EXPRESSION STATEMENT
	expr str = "Hello, world"; : EXPRESSION STATEMENT
	expr a = obj->cItemB->itemD->itemA; : EXPRESSION STATEMENT
	declr myStructA hey; : DECLARATION STATEMENT
	expr a = call obj->foo(hey, "Hey"); : EXPRESSION STATEMENT
	declr myStructB Yo; : DECLARATION STATEMENT
	call obj->boo(Yo); : CALL STATEMENT
	
	call obj->cItemC->foo(hey, "Hey"); : CALL STATEMENT
	expr a = call obj->cItemC->boo(); : EXPRESSION STATEMENT
	label1 :
	{
		declr int a; : DECLARATION STATEMENT
	} : LABEL
	expr a = add(a, call obj->myFunc(5, (true or false), str, c)); : EXPRESSION STATEMENT
	loop while(true){
		declr int i; : DECLARATION STATEMENT
		if( ((a and b) or add(a, call obj->myFunc(5, 10, "Hema", 'c'))) ) : CONDITIONAL STATEMENT{
			
			call obj->myFunc(5, add(a, 10.0), "Hema", 'c'); : CALL STATEMENT
			
		}
		declr int i; : DECLARATION STATEMENT
		call obj->myFunc(i, 10, "Hema", 'c'); : CALL STATEMENT
	} : LOOP
	
}


	
func int main() : FUNCTION HEAD
{
	declr int a; : DECLARATION STATEMENT
	expr a = 10; : EXPRESSION STATEMENT
	return 10; : RETURN STATEMENT
}


func vect<myStruct> matr_add (matrix A, matrix B) : FUNCTION HEAD{
    return add_matx(A, B); : RETURN STATEMENT
}

func vect<M> boo(int num, float nums) : FUNCTION HEAD {
	return mul(num, (num gt 10)); : RETURN STATEMENT
}
	
func vect<int> foo(int p, int q) : FUNCTION HEAD {
	expr a = add(sItem1,